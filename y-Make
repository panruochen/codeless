#!/usr/bin/env python2

# vim: tabstop=4 expandtab shiftwidth=4 softtabstop=4

YZ_EXTDIR = 'pyext'

import re, os, sys, getopt, subprocess
sys.path.append(os.path.dirname(sys.argv[0]) + '/' + YZ_EXTDIR)
import cu_lib

YZ_CC               = None
YZ_PXCC             = None

YZ_DEP_FILE         = None
YZ_CL_FILE          = None
YZ_BY_FILE          = None
YZ_IMP_BYFILE       = None
YZ_SHELL            = None
YZ_BYPASS           = ""

def do_execp(cmd, errors='abort') :
    sp = subprocess.Popen(cmd, stdout=subprocess.PIPE)
    out, err = sp.communicate()
    if errors != 'ignore' and sp.returncode :
        print >>sys.stderr, "Got return code %d while executing:\n  %s" % (sp.returncode, ' '.join(cmd))
        exit(1)
    return out

def do_exec(cmd, errors='abort') :
    sp = subprocess.Popen(cmd, shell=True, executable='/bin/bash')
    sp.wait()
    if errors != 'ignore' and sp.returncode :
        raise Exception("***(2) CMD FAILED");

def to_abs_path(x) :
    if x[0:1] != '/' :
        return os.getcwd() + '/' + x
    return x


#================================================
#
#  The main entry
#
#================================================

short_options = ''
long_options = (["yz-cc=", "yz-xcc=", 'yz-save-dep=', "yz-save-dependency=", 'yz-save-cl=', 'yz-save-command-line=',
    'yz-shell=', 'yz-bypass=', "yz-save-bypass=", "yz-import-bypass="])

a, make_args = cu_lib.collect_options(short_options, long_options, sys.argv[1:])

'''
print a
print '--------------------------------'
print make_args
print '--------------------------------'
exit(0)
'''

try:
    opts, args = getopt.gnu_getopt(a, short_options, long_options)
except getopt.GetoptError as err:
    print >>sys.stderr, str(err)
    exit(2)

for o, a in opts:
    o = o[len('--yz-'):]
    if o == 'cc':
        YZ_CC = a
    elif o == 'xcc':
        YZ_PXCC = to_abs_path(a)
    elif o.find('save-dep') == 0 :
        YZ_DEP_FILE = to_abs_path(a)
    elif o == 'save-cl' or o == 'save-command-line' :
        YZ_CL_FILE = to_abs_path(a)
    elif o == 'save-bypass' :
        YZ_BY_FILE = to_abs_path(a)
    elif o == 'import-bypass' :
        YZ_IMP_BYFILE = to_abs_path(a)
    elif o == 'shell' :
        YZ_SHELL = a
    elif o == 'bypass' :
        YZ_BYPASS += ' --yz-bypass=' + a

if YZ_PXCC == None:
    YZ_PXCC = to_abs_path(os.path.dirname(sys.argv[0]) + "/ycpp.exe")

YZ_CC_PATH = do_execp(['which', YZ_CC]).rstrip('\r\n')
if YZ_CC_PATH == '':
    print >>sys.stderr, "No such file: ", YZ_CC
    exit(2)

my_args = ' --yz-cc=' + YZ_CC + ' --yz-verbose=0 --yz-in-place=.bak'
if YZ_DEP_FILE is not None :
    my_args += ' --yz-save-dependency=' + YZ_DEP_FILE
    open(YZ_DEP_FILE, "w").close()
if YZ_CL_FILE is not None :
    my_args += ' --yz-save-command-line=' + YZ_CL_FILE
    open(YZ_CL_FILE, "w").close()
if YZ_BY_FILE is not None :
    my_args += ' --yz-save-bypass=' + YZ_BY_FILE
    open(YZ_BY_FILE, "w").close()
if YZ_IMP_BYFILE is not None :
    my_args += ' --yz-import-bypass=' + YZ_IMP_BYFILE
if YZ_BYPASS :
    my_args += YZ_BYPASS

final_commands  = 'function ' + YZ_CC + '()\n{\n    '
final_commands += YZ_PXCC + my_args
final_commands += ' "$@" || return $?\n'
final_commands += '    ' + YZ_CC_PATH
final_commands += ' $*\n}\n'

YZ_CXX = ''
if re.match(r'gcc$', YZ_CC) :
    YZ_CXX = YZ_CC[0:len(YZ_CC)-3] + 'g++'
    YZ_CXX_PATH = do_execp(['which', YZ_CXX]).rstrip('\r\n')
    if YZ_CXX_PATH == '' :
        print >>sys.stderr, "No such file: ", YZ_CXX
        exit(2)
    final_commands += 'function ' + YZ_CXX + '()\n{\n    '
    final_commands += YZ_PXCC + my_args
    final_commands += ' "$@" || return $?\n'
    final_commands += '    ' + YZ_CXX_PATH
    final_commands += ' $*\n}\n'

final_commands += 'export -f ' + YZ_CC + ' ' + YZ_CXX + '\n'
final_commands += do_execp(['which', 'make']).rstrip('\r\n')
final_commands += make_args
if YZ_SHELL != None :
    final_commands += ' SHELL=' + YZ_SHELL + ' '
final_commands += '\n'

print final_commands

sp = subprocess.Popen(final_commands, shell=True, executable='/bin/bash')
sp.wait()
if sp.returncode :
    print >>sys.stderr, "yMake got error %d" % sp.returncode

exit(sp.returncode)
